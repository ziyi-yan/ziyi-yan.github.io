{"componentChunkName":"component---src-post-index-tsx","path":"/pointer-receiver-or-value-receiver-in-go","result":{"pageContext":{"post":{"excerpt":"TL;DR 方法的 receiver 通常使用 pointer。如果不确定用什么，就用 pointer。（参考Go Code Review Guidelines - Receiver Type） slices，maps，channels，strings，functions…","html":"<h2 id=\"tldr\" style=\"position:relative;\">TL;DR</h2>\n<ul>\n<li>方法的 receiver 通常使用 pointer。如果不确定用什么，就用 pointer。（参考<a href=\"https://github.com/golang/go/wiki/CodeReviewComments#receiver-type\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Go Code Review Guidelines - Receiver Type</a>）</li>\n<li>slices，maps，channels，strings，functions value，interface 的内部实现使用了 pointer，所以不需要使用指向这些类型的 pointer 来避免 copy。</li>\n<li>对于很大的 struct 或者需要修改其内容的 struct，使用 pointer。否则，使用 value。</li>\n</ul>\n<h2 id=\"经常会使用-pointer-的情况\" style=\"position:relative;\">经常会使用 pointer 的情况</h2>\n<ul>\n<li>一个方法的参数可能有各种不同的情况，但是方法的 receiver 一般都是 pointer。方法通常都会对 receiver 做修改，并且 receiver struct 的 size 一般都比较大。</li>\n</ul>\n<h2 id=\"可以不使用-pointer-的情况\" style=\"position:relative;\">可以不使用 pointer 的情况</h2>\n<ul>\n<li>根据 Go Code Review Guidelines，不推荐使用小的 struct 的传 pointer 参数。尽管 struct 可能不是特别的小，但是，除非你需要对一个 struct 做 in-place 的修改，一般都传 value 参数。</li>\n<li>value 的语意可以避免 aliasing（比如，Java 里面的对象都是 reference，传参数就是 aliasing，名字不同但是其实是一个对象）。这样，不会不小心改了一个变量的内容，另一个变量的内容也变了。</li>\n<li>有的时候，对小的 struct 传 value 更加高效，可以避免<a href=\"https://en.wikipedia.org/wiki/Locality_of_reference\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">缓存未命中</a>（cache miss）和 heap allocation 开销。</li>\n<li>对于 slice，你不需要传 pointer 就能修改其内容。例如，<code>io.Reader.Read(p []byte)</code>会写入小于 p 的长度的 byte 到 p 里。其实，这也是一种\"对于小的 struct 传 value\"情况的一种特例。由于 slice 的内部实现（参考<a href=\"http://research.swtch.com/godata\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Russ Cox 的文章</a>），你其实传递的是一个 slice header 的小 struct。</li>\n<li>对于需要进行切片操作的 slice（通过<code>s[start:end]</code>修改其 start/end/length/capacity），可模仿<code>append()</code>函数的设计。<code>append()</code>函数接受一个 slice 再返回一个新的 slice。这样的接口避免了 aliasing，并告诉调用方新的 slice 指向 array 可能是重新分配的。</li>\n<li>map，channel，string，function value 和 interface value，和 slice 类似，内部实现都是 pointer 或者饱含一些 pointer 的 struct（<a href=\"http://research.swtch.com/interfaces\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">interface 实现</a>）。对他们直接传 value 不会导致对其内容的拷贝。</li>\n</ul>\n<h2 id=\"可能需要使用-pointer-的情况\" style=\"position:relative;\">可能需要使用 pointer 的情况</h2>\n<ul>\n<li>如果你编写了一个 function 并且接收一个 struct 的 pointer 来修改其内容，最好让这个 function 成为这个 struct 的 method。大家一般都会默认 struct 的 method 可能会修改其内容，所以 receiver 参数使用 pointer 是最容易让调用方接受的方式。</li>\n<li>对于需要修改其 non-receiver 参数内容的函数，最好在 godoc 或者函数命名上明确表达出来。例如，<code>reader.WriteTo(writer)</code>。</li>\n<li>\n<p>有时，使用传 pointer 来允许调用方复用 struct，减少内存分配是一个好处。但是，当没有出现明显的内存开销的时候，我们可以采用一些方法来避免这种非常有技巧性的 API 设计：</p>\n<ol>\n<li>为了避免内存分配开销，Go 的逃逸分析（<a href=\"http://en.wikipedia.org/wiki/Escape_analysis\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">escape analysis</a>）可以帮到你。你可以通过使用简单的构造函数、普通的字面值（literal）和有用的 zero value（像 bytes.Buffer）来最大化逃逸分析的优化效果。</li>\n<li>考虑给对象加一个 Reset()方法来让对象回到空值的状态。不在乎内存开销的用户也可以不使用这个方法。</li>\n<li>考虑即实现一个 modify-in-place 的函数，又实现一个 create-from-scratch 的函数，以供用户使用。例如，<code>existingUser.LoadFromJSON(json []byte) error</code> （从加载内容到一个 user 对象中）和  <code>NewUserFromJSON(json []byte) (*User, error)</code>（创建一个新的 user），其中后一个函数可以利用前一个函数实现。调用方可以根据需要来选择任何一种内存分配方式。</li>\n<li>需要循环利用内存的人可以考虑使用<code>sync.Pool</code>来帮助你。如果某个特定的内存分配操作制造了大量的内存压力，你很清楚的知道合适分配的对象不再需要了，但是有没有更好的优化方案，<code>sync.Pool</code>可以很好的解决这个问题。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"是否使用-slice-of-pointers-s-mystruct\" style=\"position:relative;\">是否使用 slice of pointers (<code>s []\\*MyStruct</code>)</h2>\n<p>一般情况下，slice of values 够用了，也能减少 heap allocation 和 cache miss。但是也有些情况导致必须使用 slice of pointers。</p>\n<ul>\n<li>构造 API 只允许你获取到 struct 的 pointer。例如，<code>NewFoo() *Foo</code>。</li>\n<li>slice 中 struct 的生命周期不相同。由于 slice 内部的 array 是统一回收的。如果只有其中一部分被引用会导致整个 array 不会被释放。</li>\n<li>拷贝某些 struct 可能会导致一些问题。使用<code>append()</code>函数时，array 的内容可能会被拷贝到新分配的 array 上。拷贝大的 struct 会很慢，同时有些 struct（例如<code>sync.Mutex</code>）是不允许拷贝的。在 slice 中插入和删除 item 也可能引发类似的拷贝。</li>\n</ul>\n<p>总的来说，value slices 在你不需要移动 slice 中的内容时，是比较好的选择。或者，你需要确保 slice 中的 value 在拷贝到新的内存上时，不会引发什么问题。</p>\n<h2 id=\"参考\" style=\"position:relative;\">参考</h2>\n<p>本文内容整理自 <a href=\"https://stackoverflow.com/a/23551970\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://stackoverflow.com/a/23551970</a></p>","timeToRead":4,"frontmatter":{"date":"2019-04-19T00:00:00.000Z","tags":["golang"],"title":"Go语言的方法Receiver使用Pointer还是Value？"},"parent":{"mtimeMs":1583438238840.9263,"name":"pointer-receiver-or-value-receiver-in-go"},"path":"/pointer-receiver-or-value-receiver-in-go","headings":[{"content":"TL;DR","hash":"tldr"},{"content":"经常会使用 pointer 的情况","hash":"经常会使用-pointer-的情况"},{"content":"可以不使用 pointer 的情况","hash":"可以不使用-pointer-的情况"},{"content":"可能需要使用 pointer 的情况","hash":"可能需要使用-pointer-的情况"},{"content":"是否使用 slice of pointers (s []\\*MyStruct)","hash":"是否使用-slice-of-pointers-s-mystruct"},{"content":"参考","hash":"参考"}]}}}}