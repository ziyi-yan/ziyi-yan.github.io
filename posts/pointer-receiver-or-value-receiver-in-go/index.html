


<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>
    
    Go语言的方法Receiver使用Pointer还是Value？ | Ziyi Yan
    
  </title>
  
  
  
  <link rel="stylesheet" href="https://ziyi-yan.github.io/css/base.min.32ba2cd1d9ea1221a2b3ac419294a491f54500b129bf37f06a9a023a9c4ea737.css" integrity="sha256-Mros0dnqEiGis6xBkpSkkfVFALEpvzfwapoCOpxOpzc=" crossorigin="anonymous">
  
  
  <meta name="generator" content="Hugo 0.56.3" />
</head>
<body>
  <nav class="u-background">
  <div class="u-wrapper">
    <ul class="Banner">
      <li class="Banner-item Banner-item--title">
        <a class="Banner-link u-clickable" href="https://ziyi-yan.github.io/">Ziyi Yan</a>
      </li>
      
      <li class="Banner-item">
        <a class="Banner-link u-clickable" href="https://ziyi-yan.github.io/about/">About</a>
      </li>
      
      <li class="Banner-item">
        <a class="Banner-link u-clickable" href="https://ziyi-yan.github.io/posts/">Posts</a>
      </li>
      
      <li class="Banner-item">
        <a class="Banner-link u-clickable" href="https://ziyi-yan.github.io/tags/">Tags</a>
      </li>
      
      <li class="Banner-item">
        <a class="Banner-link u-clickable" href="https://ziyi-yan.github.io/categories/">Categories</a>
      </li>
      
      <li class="Banner-item">
        <a class="Banner-link u-clickable" href="https://ziyi-yan.github.io/index.xml">RSS</a>
      </li>
      
    </ul>
  </div>
</nav>

  <main>
    <div class="u-wrapper">
      <div class="u-padding">
        

<article>
  <header class="Heading">
  <h2 class="Heading-title">
    <a class="Heading-link u-clickable" href="https://ziyi-yan.github.io/posts/pointer-receiver-or-value-receiver-in-go/" rel="bookmark">Go语言的方法Receiver使用Pointer还是Value？</a>
  </h2>
  
  <time datetime="2019-04-19T08:00:00&#43;08:00">
    19 April, 2019
  </time>
  
</header>

  

<h1 id="tl-dr">TL;DR</h1>

<ul>
<li>方法的receiver通常使用pointer。如果不确定用什么，就用pointer。（参考<a href="https://github.com/golang/go/wiki/CodeReviewComments#receiver-type">Go Code Review Guidelines - Receiver Type</a>）</li>
<li>slices，maps，channels，strings，functions value，interface的内部实现使用了pointer，所以不需要使用指向这些类型的pointer来避免copy。</li>
<li>对于很大的struct或者需要修改其内容的struct，使用pointer。否则，使用value。</li>
</ul>

<h1 id="经常会使用pointer的情况">经常会使用pointer的情况</h1>

<ul>
<li>一个方法的参数可能有各种不同的情况，但是方法的receiver一般都是pointer。方法通常都会对receiver做修改，并且receiver struct的size一般都比较大。</li>
</ul>

<h1 id="可以不使用pointer的情况">可以不使用pointer的情况</h1>

<ul>
<li><p>根据Go Code Review Guidelines，不推荐使用小的struct的传pointer参数。尽管struct可能不是特别的小，但是，除非你需要对一个struct做in-place的修改，一般都传value参数。</p></li>

<li><p>value的语意可以避免aliasing（比如，Java里面的对象都是reference，传参数就是aliasing，名字不同但是其实是一个对象）。这样，不会不小心改了一个变量的内容，另一个变量的内容也变了。</p></li>

<li><p>有的时候，对小的struct传value更加高效，可以避免<a href="https://en.wikipedia.org/wiki/Locality_of_reference">缓存未命中</a>（cache miss）和heap allocation开销。</p></li>

<li><p>对于slice，你不需要传pointer就能修改其内容。例如，<code>io.Reader.Read(p []byte)</code>会写入小于p的长度的byte到p里。其实，这也是一种&rdquo;对于小的struct传value&rdquo;情况的一种特例。由于slice的内部实现（参考<a href="http://research.swtch.com/godata">Russ Cox的文章</a>），你其实传递的是一个slice header的小struct。</p></li>

<li><p>对于需要进行切片操作的slice（通过<code>s[start:end]</code>修改其start/end/length/capacity），可模仿<code>append()</code>函数的设计。<code>append()</code>函数接受一个slice再返回一个新的slice。这样的接口避免了aliasing，并告诉调用方新的slice指向array可能是重新分配的。</p></li>

<li><p>map，channel，string，function value和interface value，和slice类似，内部实现都是pointer或者饱含一些pointer的struct（<a href="http://research.swtch.com/interfaces">interface实现</a>）。对他们直接传value不会导致对其内容的拷贝。</p></li>
</ul>

<h1 id="可能需要使用pointer的情况">可能需要使用pointer的情况</h1>

<ul>
<li>如果你编写了一个function并且接收一个struct的pointer来修改其内容，最好让这个function成为这个struct的method。大家一般都会默认struct的method可能会修改其内容，所以receiver参数使用pointer是最容易让调用方接受的方式。</li>
<li>对于需要修改其non-receiver参数内容的函数，最好在godoc或者函数命名上明确表达出来。例如，<code>reader.WriteTo(writer)</code>。</li>

<li><p>有时，使用传pointer来允许调用方复用struct，减少内存分配是一个好处。但是，当没有出现明显的内存开销的时候，我们可以采用一些方法来避免这种非常有技巧性的API设计：</p>

<ol>
<li>为了避免内存分配开销，Go的逃逸分析（<a href="http://en.wikipedia.org/wiki/Escape_analysis">escape analysis</a>）可以帮到你。你可以通过使用简单的构造函数、普通的字面值（literal）和有用的zero value（像bytes.Buffer）来最大化逃逸分析的优化效果。</li>
<li>考虑给对象加一个Reset()方法来让对象回到空值的状态。不在乎内存开销的用户也可以不使用这个方法。</li>
<li>考虑即实现一个modify-in-place的函数，又实现一个create-from-scratch的函数，以供用户使用。例如，<code>existingUser.LoadFromJSON(json []byte) error</code> （从加载内容到一个user对象中）和 <code>NewUserFromJSON(json []byte) (*User, error)</code>（创建一个新的user），其中后一个函数可以利用前一个函数实现。调用方可以根据需要来选择任何一种内存分配方式。</li>
<li>需要循环利用内存的人可以考虑使用<code>sync.Pool</code>来帮助你。如果某个特定的内存分配操作制造了大量的内存压力，你很清楚的知道合适分配的对象不再需要了，但是有没有更好的优化方案，<code>sync.Pool</code>可以很好的解决这个问题。</li>
</ol></li>
</ul>

<h1 id="是否使用slice-of-pointers-s-mystruct">是否使用slice of pointers（s []*MyStruct)</h1>

<p>一般情况下，slice of values够用了，也能减少heap allocation和cache miss。但是也有些情况导致必须使用slice of pointers。</p>

<ul>
<li>构造API只允许你获取到struct的pointer。例如，<code>NewFoo() *Foo</code>。</li>
<li>slice中struct的生命周期不相同。由于slice内部的array是统一回收的。如果只有其中一部分被引用会导致整个array不会被释放。</li>
<li>拷贝某些struct可能会导致一些问题。使用<code>append()</code>函数时，array的内容可能会被拷贝到新分配的array上。拷贝大的struct会很慢，同时有些struct（例如<code>sync.Mutex</code>）是不允许拷贝的。在slice中插入和删除item也可能引发类似的拷贝。</li>
</ul>

<p>总的来说，value slices在你不需要移动slice中的内容时，是比较好的选择。或者，你需要确保slice中的value在拷贝到新的内存上时，不会引发什么问题。</p>

<h1 id="参考">参考</h1>

<p>本文内容整理自 <a href="https://stackoverflow.com/a/23551970">https://stackoverflow.com/a/23551970</a></p>

  
<footer>
  <ul class="Tags">
    
    
    
    <li class="Tags-item u-background">
      <a class="Tags-link u-clickable" href="https://ziyi-yan.github.io/tags/golang/" rel="tag">golang</a>
    </li>
    
    
  </ul>
</footer>


  



</article>


      </div>
    </div>
  </main>
  
<footer class="Footer">
  <div class="u-wrapper">
    <div class="u-padding">
      Except where otherwise noted, content on this site is licensed under a <a href="http://creativecommons.org/licenses/by/4.0/" rel="license"> Creative Commons Attribution 4.0 International License</a>.
    </div>
  </div>
</footer>


</body>
</html>
