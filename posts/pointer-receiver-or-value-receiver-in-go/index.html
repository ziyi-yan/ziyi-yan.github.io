<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>【译】Go语言的方法Receiver使用Pointer还是Value？ - Ziyi Yan | 严子怡</title>
    <meta property="og:title" content="【译】Go语言的方法Receiver使用Pointer还是Value？ - Ziyi Yan | 严子怡">
    
    <meta name="twitter:card" content="summary">

    
      
    

    
      
      <meta property="description" content="根据Go Code Review Guidelines，不推荐使用小的struct的传pointer参数。尽管struct可能不是特别的小，但是，除非你需要对一个struct做in-place的修改，一般都传value参数。
[&amp;hellip;] value的语意可以避免aliasing（比如，Java里面的对象都是reference，传参数就是aliasing，名字不同但是其实是一个对象）。这 &amp;hellip;">
      <meta property="og:description" content="根据Go Code Review Guidelines，不推荐使用小的struct的传pointer参数。尽管struct可能不是特别的小，但是，除非你需要对一个struct做in-place的修改，一般都传value参数。
[&amp;hellip;] value的语意可以避免aliasing（比如，Java里面的对象都是reference，传参数就是aliasing，名字不同但是其实是一个对象）。这 &amp;hellip;">
      
    

    
    

    

    
    

    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  
  <body class="posts">
    <header class="masthead">
      <h1><a href="/">Ziyi Yan | 严子怡</a></h1>



      <nav class="menu">
  <input id="menu-check" type="checkbox" />
  <label id="menu-label" for="menu-check" class="unselectable">
    <span class="icon close-icon">✕</span>
    <span class="icon open-icon">☰</span>
    <span class="text">Menu</span>
  </label>
  <ul>
  
  
  <li><a href="/">首页</a></li>
  
  <li><a href="/posts">日志</a></li>
  
  <li><a href="/about/">关于</a></li>
  
  <li><a href="/categories/">分类</a></li>
  
  <li><a href="/tags/">标签</a></li>
  
  <li><a href="/index.xml">订阅</a></li>
  
  
  </ul>
</nav>

    </header>

    <article class="main">
      <header class="title">
      
<h1>【译】Go语言的方法Receiver使用Pointer还是Value？</h1>

<h3>严子怡
  /  2019-04-19</h3>
<hr>


      </header>





<h2 id="tl-dr">TL;DR</h2>

<ul>
<li>方法的receiver通常使用pointer。如果不确定用什么，就用pointer。（参考<a href="https://github.com/golang/go/wiki/CodeReviewComments#receiver-type">Go Code Review Guidelines - Receiver Type</a>）</li>
<li>slices，maps，channels，strings，functions value，interface的内部实现使用了pointer，所以不需要使用指向这些类型的pointer来避免copy。</li>
<li>对于很大的struct或者需要修改其内容的struct，使用pointer。否则，使用value。</li>
</ul>

<h2 id="经常会使用pointer的情况">经常会使用pointer的情况</h2>

<ul>
<li>一个方法的参数可能有各种不同的情况，但是方法的receiver一般都是pointer。方法通常都会对receiver做修改，并且receiver struct的size一般都比较大。</li>
</ul>

<h2 id="可以不使用pointer的情况">可以不使用pointer的情况</h2>

<ul>
<li><p>根据Go Code Review Guidelines，不推荐使用小的struct的传pointer参数。尽管struct可能不是特别的小，但是，除非你需要对一个struct做in-place的修改，一般都传value参数。</p></li>

<li><p>value的语意可以避免aliasing（比如，Java里面的对象都是reference，传参数就是aliasing，名字不同但是其实是一个对象）。这样，不会不小心改了一个变量的内容，另一个变量的内容也变了。</p></li>

<li><p>有的时候，对小的struct传value更加高效，可以避免<a href="https://en.wikipedia.org/wiki/Locality_of_reference">缓存未命中</a>（cache miss）和heap allocation开销。</p></li>

<li><p>对于slice，你不需要传pointer就能修改其内容。例如，<code>io.Reader.Read(p []byte)</code>会写入小于p的长度的byte到p里。其实，这也是一种&rdquo;对于小的struct传value&rdquo;情况的一种特例。由于slice的内部实现（参考<a href="http://research.swtch.com/godata">Russ Cox的文章</a>），你其实传递的是一个slice header的小struct。</p></li>

<li><p>对于需要进行切片操作的slice（通过<code>s[start:end]</code>修改其start/end/length/capacity），可模仿<code>append()</code>函数的设计。<code>append()</code>函数接受一个slice再返回一个新的slice。这样的接口避免了aliasing，并告诉调用方新的slice指向array可能是重新分配的。</p></li>

<li><p>map，channel，string，function value和interface value，和slice类似，内部实现都是pointer或者饱含一些pointer的struct（<a href="http://research.swtch.com/interfaces">interface实现</a>）。对他们直接传value不会导致对其内容的拷贝。</p></li>
</ul>

<h2 id="可能需要使用pointer的情况">可能需要使用pointer的情况</h2>

<ul>
<li>如果你编写了一个function并且接收一个struct的pointer来修改其内容，最好让这个function成为这个struct的method。大家一般都会默认struct的method可能会修改其内容，所以receiver参数使用pointer是最容易让调用方接受的方式。</li>
<li>对于需要修改其non-receiver参数内容的函数，最好在godoc或者函数命名上明确表达出来。例如，<code>reader.WriteTo(writer)</code>。</li>

<li><p>有时，使用传pointer来允许调用方复用struct，减少内存分配是一个好处。但是，当没有出现明显的内存开销的时候，我们可以采用一些方法来避免这种非常有技巧性的API设计：</p>

<ol>
<li>为了避免内存分配开销，Go的逃逸分析（<a href="http://en.wikipedia.org/wiki/Escape_analysis">escape analysis</a>）可以帮到你。你可以通过使用简单的构造函数、普通的字面值（literal）和有用的zero value（像bytes.Buffer）来最大化逃逸分析的优化效果。</li>
<li>考虑给对象加一个Reset()方法来让对象回到空值的状态。不在乎内存开销的用户也可以不使用这个方法。</li>
<li>考虑即实现一个modify-in-place的函数，又实现一个create-from-scratch的函数，以供用户使用。例如，<code>existingUser.LoadFromJSON(json []byte) error</code> （从加载内容到一个user对象中）和 <code>NewUserFromJSON(json []byte) (*User, error)</code>（创建一个新的user），其中后一个函数可以利用前一个函数实现。调用方可以根据需要来选择任何一种内存分配方式。</li>
<li>需要循环利用内存的人可以考虑使用<code>sync.Pool</code>来帮助你。如果某个特定的内存分配操作制造了大量的内存压力，你很清楚的知道合适分配的对象不再需要了，但是有没有更好的优化方案，<code>sync.Pool</code>可以很好的解决这个问题。</li>
</ol></li>
</ul>

<h2 id="是否使用slice-of-pointers-s-mystruct">是否使用slice of pointers（s []*MyStruct)</h2>

<p>一般情况下，slice of values够用了，也能减少heap allocation和cache miss。但是也有些情况导致必须使用slice of pointers。</p>

<ul>
<li>构造API只允许你获取到struct的pointer。例如，<code>NewFoo() *Foo</code>。</li>
<li>slice中struct的生命周期不相同。由于slice内部的array是统一回收的。如果只有其中一部分被引用会导致整个array不会被释放。</li>
<li>拷贝某些struct可能会导致一些问题。使用<code>append()</code>函数时，array的内容可能会被拷贝到新分配的array上。拷贝大的struct会很慢，同时有些struct（例如<code>sync.Mutex</code>）是不允许拷贝的。在slice中插入和删除item也可能引发类似的拷贝。</li>
</ul>

<p>总的来说，value slices在你不需要移动slice中的内容时，是比较好的选择。或者，你需要确保slice中的value在拷贝到新的内存上时，不会引发什么问题。</p>

<h2 id="参考">参考</h2>

<p>本文内容整理自 <a href="https://stackoverflow.com/a/23551970">https://stackoverflow.com/a/23551970</a></p>


  <footer>
  
  

  
  <hr>
  <div class="copyright">&copy; <a href="https://ziyi-yan.github.io">Ziyi Yan</a> 2018 - 2019 | <a href="https://github.com/ziyi-yan">GitHub</a> | <a href="https://twitter.com/ZiyiYan23">Twitter</a> | <a href="https://linkedin.com/in/ziyi-yan">LinkedIn</a></div>
  
  </footer>
  </article>
  
  </body>
</html>

