<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>主页 on Ziyi Yan | 严子怡</title>
    <link>https://ziyi-yan.github.io/</link>
    <description>Recent content in 主页 on Ziyi Yan | 严子怡</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 25 Dec 2018 22:53:24 +0800</lastBuildDate>
    
	<atom:link href="https://ziyi-yan.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>【译】Go语言的方法Receiver使用Pointer还是Value？</title>
      <link>https://ziyi-yan.github.io/posts/pointer-receiver-or-value-receiver-in-go/</link>
      <pubDate>Fri, 19 Apr 2019 08:00:00 +0800</pubDate>
      
      <guid>https://ziyi-yan.github.io/posts/pointer-receiver-or-value-receiver-in-go/</guid>
      <description>TL;DR  方法的receiver通常使用pointer。如果不确定用什么，就用pointer。（参考Go Code Review Guidelines - Receiver Type） slices，maps，channels，strings，functions value，interface的内部实现使用了pointer，所以不需要使用指向这些类型的pointer来避免copy。 对于很大的struct或者需要修改其内容的struct，使用pointer。否则，使用value。  经常会使用pointer的情况  一个方法的参数可能有各种不同的情况，但是方法的receiver一般都是pointer。方法通常都会对receiver做修改，并且receiver struct的size一般都比较大。  可以不使用pointer的情况  根据Go Code Review Guidelines，不推荐使用小的struct的传pointer参数。尽管struct可能不是特别的小，但是，除非你需要对一个struct做in-place的修改，一般都传value参数。
 value的语意可以避免aliasing（比如，Java里面的对象都是reference，传参数就是aliasing，名字不同但是其实是一个对象）。这样，不会不小心改了一个变量的内容，另一个变量的内容也变了。
 有的时候，对小的struct传value更加高效，可以避免缓存未命中（cache miss）和heap allocation开销。
 对于slice，你不需要传pointer就能修改其内容。例如，io.Reader.Read(p []byte)会写入小于p的长度的byte到p里。其实，这也是一种&amp;rdquo;对于小的struct传value&amp;rdquo;情况的一种特例。由于slice的内部实现（参考Russ Cox的文章），你其实传递的是一个slice header的小struct。
 对于需要进行切片操作的slice（通过s[start:end]修改其start/end/length/capacity），可模仿append()函数的设计。append()函数接受一个slice再返回一个新的slice。这样的接口避免了aliasing，并告诉调用方新的slice指向array可能是重新分配的。
 map，channel，string，function value和interface value，和slice类似，内部实现都是pointer或者饱含一些pointer的struct（interface实现）。对他们直接传value不会导致对其内容的拷贝。
  可能需要使用pointer的情况  如果你编写了一个function并且接收一个struct的pointer来修改其内容，最好让这个function成为这个struct的method。大家一般都会默认struct的method可能会修改其内容，所以receiver参数使用pointer是最容易让调用方接受的方式。 对于需要修改其non-receiver参数内容的函数，最好在godoc或者函数命名上明确表达出来。例如，reader.WriteTo(writer)。 有时，使用传pointer来允许调用方复用struct，减少内存分配是一个好处。但是，当没有出现明显的内存开销的时候，我们可以采用一些方法来避免这种非常有技巧性的API设计：
 为了避免内存分配开销，Go的逃逸分析（escape analysis）可以帮到你。你可以通过使用简单的构造函数、普通的字面值（literal）和有用的zero value（像bytes.Buffer）来最大化逃逸分析的优化效果。 考虑给对象加一个Reset()方法来让对象回到空值的状态。不在乎内存开销的用户也可以不使用这个方法。 考虑即实现一个modify-in-place的函数，又实现一个create-from-scratch的函数，以供用户使用。例如，existingUser.LoadFromJSON(json []byte) error （从加载内容到一个user对象中）和 NewUserFromJSON(json []byte) (*User, error)（创建一个新的user），其中后一个函数可以利用前一个函数实现。调用方可以根据需要来选择任何一种内存分配方式。 需要循环利用内存的人可以考虑使用sync.Pool来帮助你。如果某个特定的内存分配操作制造了大量的内存压力，你很清楚的知道合适分配的对象不再需要了，但是有没有更好的优化方案，sync.Pool可以很好的解决这个问题。   是否使用slice of pointers（s []*MyStruct) 一般情况下，slice of values够用了，也能减少heap allocation和cache miss。但是也有些情况导致必须使用slice of pointers。</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>https://ziyi-yan.github.io/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ziyi-yan.github.io/about/</guid>
      <description>我 毕业于华中科技大学，电子信息与通信学院，基于项目的信息类专业教育实验班。
目前是一名后端开发工程师，Gopher。</description>
    </item>
    
  </channel>
</rss>